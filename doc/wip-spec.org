#+title: Minimal Intercal C Language Specification
#+author: Qifan Wang

This is a draft

* Summary

** Currently supported

Note that the tokenizer assumes the host Common Lisp has
been properly setup that the stream converts =\n= or =\r\n=
to a dedicated =#\Newline= character according to platform's
convention.

- All keywords from ISO C99
- C99 decimal and octal integers
- C99 identifiers
- All C99 punctuactors except =##= and =%:%:=, they are
  only used in preprocessor.
- =/* */= and =//= comment

** Planned but not implemented

At current stage, these can result in unexpected error
been reported while lexing. There might be a chance they get
implemented when parser has been started, or maybe not.

- Strings and character literals
- Token =...=

TBD

** Differences to ISO C99

The parsing does not adhere to C99 specification when it comes to how
comment and preprocessing instructions are handled. In fact,
this compiler does not attempt to expand C macros.

*** C99 features intentionally not supported

- Trigraph. They are cause trouble and even disabled by default in
  modern compilers.
- =\= follow by newline. It has little use outside defining
  C macros, thus only partially supported in macro instructions
  and single line comments.
- =L= prefix to string and character literals. It adds complexity
  to tokenization, and the compiler does not plan to support
  width char.

* Specification

** Lexical Elements

Note that ='\\'= appears in the grammar actually denotes a single =\=
character.

Tokens are optionally separated by one or more whitespaces.

Identifiers, keywords, or constants must be delimited by whitespaces,
comments, strings or punctuators.

#+BEGIN_EXAMPLE
  token:
    keyword
    identifier
    constant
    punctuator
    comment
    preprocessor-instruction
  whitespace:
    space
    tab
    newline
  space:   '\s'
  tab:     '\t'
  newline: '\n'
#+END_EXAMPLE

*** Keywords

They are:
- =auto=
- =break=
- =case=
- =char=
- =const=
- =continue=
- =default=
- =do=
- =double=
- =else=
- =enum=
- =extern=
- =float=
- =for=
- =goto=
- =if=
- =inline=
- =int=
- =long=
- =register=
- =restrict=
- =return=
- =short=
- =signed=
- =sizeof=
- =static=
- =struct=
- =switch=
- =typedef=
- =union=
- =unsigned=
- =void=
- =volatile=
- =while=
- =_Bool=
- =_Complex=
- =_Imaginary=

*** Identifier

#+BEGIN_EXAMPLE
  identifier:
    nondigit
    identifier nondigit
    identifier digit
  nondigit: one of
    '_' 'A' 'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' 'J' 'K' 'L' 'M' 'N' 'O' 'P'
    'Q' 'R' 'S' 'T' 'U' 'V' 'W' 'X' 'Y' 'Z'
    'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n' 'o' 'p'
    'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z'
  digit: one of
    '0' '1' '2' '3' '4' '5' '6' '7' '8' '9'
#+END_EXAMPLE

*** Constant

#+BEGIN_EXAMPLE
  constant:
    integer-constant
    character-constant
    string-constant
#+END_EXAMPLE

**** Integers

#+BEGIN_EXAMPLE
  integer-constant:
    decimal-constant integer-suffix?
    octal-constant integer-suffix?
  decimal-constant:
    nonzero-digit
    decimal-constant digit
  octal-constant:
    '0'
    octal-constant octal-digit
  nonzero-digit: one of
    '1' '2' '3' '4' '5' '6' '7' '8' '9'
  octal-digit: one of
    '0' '1' '2' '3' '4' '5' '6' '7'
#+END_EXAMPLE

Obviously, =0= is an octal constant.

**** Character literal

#+BEGIN_EXAMPLE
  character-constant:
    '\'' c-char* '\''
  c-char:
    "any character except '\'', '\\', or '\n'"
    escape-sequence
  escape-sequence: one of
    '\\\'' '\\\"' '\\?' '\\\\' '\\a' '\\b'
    '\\f' '\\n' '\\r' '\\t' '\\v'
#+END_EXAMPLE

**** String literal

#+BEGIN_EXAMPLE
  string-literal:
    '"' s-char* '"'
  s-char:
    "any character except '"', '\\', or '\n'"
    escape-sequence
  escape-sequence: one of
    '\\\'' '\\\"' '\\?' '\\\\' '\\a' '\\b'
    '\\f' '\\n' '\\r' '\\t' '\\v'
#+END_EXAMPLE

*** Comment syntax and Preprocessor instructions

#+BEGIN_EXAMPLE
  comment:
    multiline-comment
    singleline-comment
  multiline-comment:
    '/*' "text that does not contain '*/'" '*/'
  singleline-comment:
    '//' [ "text that does not contain '\n'" '\\' '\n' ]*
           "text that does not contain '\n'"? '\n'
  preprocessor-instruction:
    '#' [ "text that does not contain '\n'" '\\' '\n' ]*
          "text that does not contain '\n'"? '\n'
#+END_EXAMPLE

A multi-line comment starts with =/*= and can contain any character
sequences except the ending sequence, and ends with =*/=.

A single line comment starts with =//= and ends with a newline
that is not prefixed by the line continuation character =\=.

Preprocessor instructions is similar to single line comment
except starts with =#=.

Note that the example below is a valid comment in C99 but not accepted
by the above grammar.
#+BEGIN_SRC C
/\
/ foo
#+END_SRC

** Grammar

#+BEGIN_EXAMPLE
program:
  toplevel+

toplevel:
  function
  toplevel-variable-declaration

toplevel-variable-declaration:
  type indentifier '=' constant ';'
#+END_EXAMPLE

The grammar for C functions closely resembles K&R C, but
with a few differences.

#+BEGIN_EXAMPLE
function:
  type identifier '(' varlist? ')'
    variable-declaration
    '{' statement* '}'
varlist:
  identifier (',' varlist)*
statement:
  return-statement
  variable-declaration
  increment
  decrement
  assignment

increment:
  identifier '++'

decrement:
  identifier '--'

variable-declaration:
  type varilist ';'

return-statement:
  'return' expr ';'

assignment:
  identifier '=' expr ';'

expr:
  identifier
  constant
  binary-op

binary-op:
  atom '+' atom
  atom '-' atom

atom:
  identifier
  constant
#+END_EXAMPLE

